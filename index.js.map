{"version":3,"file":"index.js","sources":["webpack:///webpack/bootstrap 436869776870bd2128ca","webpack:///./src/index.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 436869776870bd2128ca","interface Pos {\n    x: number\n    y: number\n}\n\ntype CellsRow = Array<Cell>\n\nclass Grid {\n    public cellsX: number\n    public cellsY: number\n\n    public cells: Array<CellsRow>\n\n    constructor(x: number, y: number) {\n        this.cellsX = x\n        this.cellsY = y\n\n        this.cells = []\n\n        for(let i: number = 0; i < y; i++) {\n            this.cells[i] = []\n            for(let c: number = 0; c < x; c++) {\n                this.cells[i][c] = new Cell(false, {x: c, y: i})\n            }\n        }\n    }\n\n    /**\n     * evalNextState\n     */\n    public evalNextState(position: Pos): boolean {\n        let cell: Cell = this.cells[position.y][position.x]\n\n        let aliveCount: number = 0\n        let positions: Array<Pos> = this.getSuroundingPositions(position)\n\n        positions.forEach(pos => {\n            if(this.checkStatus(pos)) {\n                aliveCount++\n            }\n        })\n\n        if(cell.alive) {\n            if(aliveCount === 3 || aliveCount === 2) {\n                return true\n            } else {\n                return false\n            }\n        } else {\n            if(aliveCount === 3) {\n                return true\n            } else {\n                return false\n            }\n        }\n    }\n\n    public iteratePositions(callback: (pos: Pos) => void) {\n        for(let i: number = 0; i < this.cellsY; i++) {\n            for(let c: number = 0; c < this.cellsX; c++) {\n                callback({\n                    x: c,\n                    y: i\n                })\n            }\n        }\n    }\n\n    public iterateCells(callback: (cell: Cell) => void) {\n        for(let i: number = 0; i < this.cellsY; i++) {\n            for(let c: number = 0; c < this.cellsX; c++) {\n                callback(this.cells[i][c])\n            }\n        }\n    }\n\n    getSuroundingPositions(position: Pos): Array<Pos> {\n        let positions: Array<Pos> = []\n\n        for(let y:number = -1; y <= 1; y++) {\n            for(let x: number = -1; x <= 1; x++) {\n                if(!(x === 0 && y === 0)) {\n                    let pos: Pos = {\n                        x: position.x + x,\n                        y: position.y + y,\n                    }\n\n                    positions.push(pos)\n                }\n            }\n        }\n\n        return positions\n    }\n\n    checkStatus(position: Pos): boolean {\n        return typeof this.cells[position.y] !== 'undefined' \n            && typeof this.cells[position.y][position.x] !== \"undefined\" && this.cells[position.y][position.x].alive\n    }\n\n    public setAlive(position: Pos) {\n        if(position.x < this.cellsX && position.y < this.cellsY) {\n            this.cells[position.y][position.x].setAlive()\n        }\n    }\n\n    public setDead(position: Pos) {\n        if(position.x < this.cellsX && position.y < this.cellsY) {\n            this.cells[position.y][position.x].setDead()\n        }\n    }\n\n    public static getStarting(x: number, y: number, liveCells: Array<Pos> = []): Grid {\n        let grid: Grid = new Grid(x, y)\n\n        liveCells.forEach((position: Pos) => {\n            grid.setAlive(position)\n        })\n\n        return grid\n    }\n}\n\nclass Cell {\n    alive: boolean\n    position: Pos\n\n    constructor(isAlive: boolean = false, position: Pos) {\n        this.alive = isAlive\n        this.position = position\n    }\n\n    public setAlive() {\n        this.alive = true\n    }\n\n    public setDead() {\n        this.alive = false\n    }\n}\n\ninterface GameConfig {\n    defaultGrid: Grid\n    cellWidth?: number\n}\n\nclass Game {\n    private grid: Grid\n    private canvas: HTMLCanvasElement\n    private interval: any\n    private cellWidth: number\n\n    constructor(config: GameConfig) {\n        this.canvas = <HTMLCanvasElement>document.querySelector(\"#canvas\")\n        this.grid = config.defaultGrid\n        this.cellWidth = config.cellWidth || 3\n\n\n        this.canvas.width = this.cellWidth * this.grid.cellsX\n        this.canvas.height = this.cellWidth * this.grid.cellsY\n    }\n\n    public start(stepTime: number = 500) {\n        this.render()\n        this.interval = setInterval(this.step.bind(this), stepTime)\n    }\n\n    public stop() {\n        clearInterval(this.interval)\n    }\n\n    private step() {\n        //this is where the magic happens\n        let nextGrid: Grid = Grid.getStarting(this.grid.cellsX, this.grid.cellsY)\n\n        this.grid.iteratePositions((pos: Pos) => {\n            let shouldBeAlive:boolean = this.grid.evalNextState(pos)\n            if(shouldBeAlive){\n                nextGrid.setAlive(pos)\n            } else {\n                nextGrid.setDead(pos)\n            }\n        })\n\n        this.grid = nextGrid\n\n        this.render()\n    }\n\n    render() {\n        var context = this.canvas.getContext('2d')\n        this.grid.iterateCells((cell: Cell) => {\n            let pos: Pos = cell.position\n            context.beginPath();\n            context.rect(pos.x*this.cellWidth, pos.y*this.cellWidth, this.cellWidth, this.cellWidth);\n            context.fillStyle = cell.alive ? 'black' : '#EEE';\n            context.fill();\n        })\n    }\n\n\n}\n\nlet alive: Array<Pos> = [\n    {\n        x: 11,\n        y: 10\n    },\n    {\n        x: 12,\n        y: 11\n    },\n    {\n        x: 10,\n        y: 12\n    },\n    {\n        x: 11,\n        y: 12\n    }, \n    {\n        x: 12,\n        y: 12\n    }\n]\n\nvar config: GameConfig = {\n    defaultGrid: Grid.getStarting(300, 300, alive),\n    cellWidth: 5\n}\n\n\nvar game = new Game(config)\ngame.start(50)\n\n\n\n\n\n\n\n\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;AAMA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAIA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAOA;AAMA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;;;;","sourceRoot":""}